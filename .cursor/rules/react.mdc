---
description: 
globs: **/*.tsx,**/*.ts
alwaysApply: false
---
**Objective:** Ensure generated React code uses modern functional components and hooks, promotes reusability, maintainability, and follows established React patterns.

**Core Principles:**

*   **Functional Components & Hooks:** MUST use functional components with Hooks. AVOID class components.
*   **Immutability:** Treat state and props as immutable. Never modify them directly. Use setter functions (`useState`) or create new objects/arrays for updates.
*   **Component Composition:** Favor composition over inheritance. Build complex UI by combining smaller, focused components.
*   **Unidirectional Data Flow:** Data should flow downwards from parent to child components via props. State updates flow upwards via callbacks.

**Rules:**

1.  **Component Design:**
    *   Keep components small and focused on a single responsibility (Single Responsibility Principle).
    *   Use clear and descriptive names for components and props.
    *   Utilize TypeScript (see `typescript.mdc`) for defining prop types (`interface` or `type`). Provide default props where sensible.
    *   Destructure props for clarity: `const MyComponent = ({ name, value }) => { ... };`
    *   AVOID using `index` as a key for lists when items can be added, removed, or reordered. Use stable, unique IDs.

2.  **Hooks Usage:**
    *   Use `useState` for simple component-level state.
    *   Use `useEffect` for side effects (data fetching (prefer TanStack Query), subscriptions, manual DOM manipulations). MUST include accurate dependency arrays. AVOID empty dependency arrays (`[]`) unless the effect truly runs only on mount/unmount. Provide cleanup functions for subscriptions or timers.
    *   Use `useContext` for accessing global or shared state (theming, authentication, Zustand stores) to avoid prop drilling. Keep context usage focused.
    *   Use `useReducer` for complex state logic or when the next state depends on the previous one.
    *   Use `useMemo` to memoize expensive calculations. Only apply when performance profiling indicates a bottleneck.
    *   Use `useCallback` to memoize functions passed down as props, especially event handlers provided to memoized child components (`React.memo`), to prevent unnecessary re-renders. Only apply when necessary.
    *   Create Custom Hooks (`useMyLogic`) to encapsulate and reuse stateful logic across multiple components. Custom Hooks MUST follow the `use` naming convention.

3.  **State Management:**
    *   For global client-side state, MUST use Zustand (see `zustand.mdc`).
    *   For server cache state (API data), MUST use TanStack Query (see `tanstack-query.mdc`).
    *   Lift state up to the nearest common ancestor component when multiple components need access to the same state.

4.  **Performance:**
    *   Use `React.memo` to optimize functional components by memoizing the result if props haven't changed. Use judiciously, often in conjunction with `useCallback` for function props.
    *   Virtualize long lists using libraries like `react-window` or `@tanstack/react-virtual` if performance degrades.
    *   Analyze component re-renders using React DevTools Profiler when investigating performance issues.

5.  **Error Handling:**
    *   Implement React Error Boundaries (using class components with `getDerivedStateFromError` and `componentDidCatch`, or libraries like `react-error-boundary`) to catch rendering errors in component subtrees and display fallback UI. Place them strategically (e.g., around major UI sections or routes).
    *   Use `try...catch` within event handlers and asynchronous operations inside `useEffect`.

6.  **Modularity & Reusability:**
    *   Design components to be reusable across different parts of the application where applicable.
    *   Abstract complex or repeated JSX structures into separate components.
    *   Custom Hooks are the primary mechanism for reusing stateful logic.